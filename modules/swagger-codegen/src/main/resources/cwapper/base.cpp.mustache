/*
{{{appDescription}}}

                        Please DO NOT edit this file
*/

#include "cwapper.hpp"
#include "restful.hpp"

std::ostream& operator<<(std::ostream& out, const std::vector<std::string>& v) {
    if (!v.empty()) {
        std::copy(v.begin(), v.end(), std::ostream_iterator<std::string>(out, ", "));
    }
    return out;
}

std::ostream& operator<<(std::ostream& out, const cwapper::data& v) {
    if(v.type == cwapper::JSON) {
        boost::property_tree::json_parser::write_json(out, v.tree);
    }
    if(v.type == cwapper::XML) {
        boost::property_tree::xml_parser::write_xml(out, v.tree);
    }
    return out;
}

std::ostream& operator<<(std::ostream& out, const std::vector<cwapper::data>& v) {
    //TODO: fix me

    return out;
}

template <typename T>
cppcms::http::response& operator<<(cppcms::http::response& r, const T& v) {
    r.out() << v;
    
    return r;
}

cppcms::http::response& operator<<(cppcms::http::response& r, const cwapper::data& v) {
    r.set_header("Content-Type", v.mimeType());

    r.out() << v;
    
    return r;
}

namespace cwapper {
    restful::restful(cppcms::service &srv): cppcms::application(srv) {
{{#x-cwapper}}
        dispatcher().assign("{{re}}", &restful::{{fid}}, this{{#hasPathParams}}, {{pathParams.size}}{{/hasPathParams}});
{{/x-cwapper}}

        dispatcher().assign("/__api__", &restful::__api__, this);
    }

// ====================================================================
{{#x-cwapper}}
    void restful::{{fid}}({{#pathParams}}std::string {{paramName}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}) {
{{#pathParams}}
        // {{paramName}}: {{description}}
        {{dataType}} _{{paramName}} = boost::lexical_cast<{{dataType}}>({{paramName}});
{{/pathParams}}

        CORS();

        if (request().request_method() == "OPTIONS") {
            return;
        }

{{#operations}}
        // {{summary}}
{{#description}}
        // {{.}}
{{/description}}
        if (request().request_method() == "{{httpMethod}}") {
{{#allParams}}
{{^isPathParam}}
            // {{paramName}}: {{description}}
            {{dataType}}{{#isListContainer}}<{{baseType}}>{{/isListContainer}} {{paramName}} =
{{#isBodyParam}}
                {{#isListContainer}}restful::array({{/isListContainer}}restful::body(){{#isListContainer}}){{/isListContainer}};
{{/isBodyParam}}
{{^isBodyParam}}
               {{#isListContainer}}boost::get<{{dataType}}<std::string> >(restful::parameter("{{paramName}}"));{{/isListContainer}}
               {{^isListContainer}}boost::lexical_cast<{{dataType}}>(boost::get<std::string>(restful::parameter("{{paramName}}")));{{/isListContainer}}
{{/isBodyParam}}
{{/isPathParam}}
{{/allParams}}

            std::cout << "DEBUG <method>: {{httpMethod}} " << request().path_info()
{{#allParams}}
                << std::endl << "\t{{paramName}}=" << {{paramName}}
{{/allParams}}
            << std::endl;

            {{#returnType}}response() << {{/returnType}}{{operationId}}({{#allParams}}{{#isPathParam}}_{{/isPathParam}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}});

            return;
        }
{{/operations}}

        response().make_error_response(response().not_implemented);
    }

{{#operations}}
// --------------------------------------------------------------------
    {{#returnType}}{{returnType}}{{^returnSimpleType}}<{{returnBaseType}}>{{/returnSimpleType}}{{/returnType}}{{^returnType}}void{{/returnType}} restful::{{operationId}}({{#allParams}}{{dataType}}{{#isListContainer}}<{{baseType}}>{{/isListContainer}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    {{#bodyParams}}
        return{{#returnType}} {{paramName}}{{/returnType}};
    {{/bodyParams}}
    {{^bodyParams}}
        return{{#returnType}} {{returnType}}{{#returnSimpleType}}(){{/returnSimpleType}}{{^returnSimpleType}}<{{returnBaseType}}>(){{/returnSimpleType}}{{/returnType}};
    {{/bodyParams}}
    }
{{/operations}}
// ====================================================================
{{/x-cwapper}}

    std::vector<cwapper::data> restful::array(cwapper::data data) {
        return std::vector<cwapper::data>();
    }

    cwapper::data restful::body() {
        std::pair<void*, ssize_t> post = request().raw_post_data();
        std::istringstream ss(std::string((char *)post.first, post.second));

        std::cerr << "DEBUG <body>:\t " << request().content_type() << std::endl;

        boost::property_tree::ptree tree;
        cwapper::data data;

        if (request().content_type() == "application/json") {
            data.type = cwapper::JSON;
            try {
                boost::property_tree::json_parser::read_json(ss, tree);
            } catch (boost::property_tree::json_parser::json_parser_error &e) {
                response().make_error_response(response().bad_request, e.what());
                throw cwapper::error();
            }
        }
        if (request().content_type() == "text/xml" ||
            request().content_type() == "application/xml" ) {
            data.type = cwapper::XML;
            try {
                boost::property_tree::xml_parser::read_xml(ss, tree);
            } catch (boost::property_tree::xml_parser::xml_parser_error &e) {
                response().make_error_response(response().bad_request, e.what());
                throw cwapper::error();
            }
        }
        data.tree = tree;
        return data;
    }

    cwapper::parameter restful::parameter(std::string name) {
        using namespace boost::algorithm;
    
        cppcms::http::request::form_type form = request().post_or_get();
        cwapper::parameter result;

        for(cppcms::http::request::form_type::iterator it = form.begin(); it != form.end(); it++) {
            std::string key = it->first, value = it->second;

            if(name != trim_right_copy_if(key, is_any_of("[]"))) // swagger-ui uses p[]=...&p[]=... while swagger-editor uses p=...&p=...
                continue;

            try {
                std::vector<std::string>& array = boost::get<std::vector<std::string> >(result);
                array.push_back(value);
                continue;
            } catch(boost::bad_get e) {}

            std::string& old = boost::get<std::string>(result);
            if(old.empty()) {
                result = value;
            } else {
                std::vector<std::string> array;
                array.push_back(old);
                array.push_back(value);
                result = array;
            }
        }

        return result;
    }

    void restful::CORS() {
        response().set_header("Content-Type",
            request().http_accept());

        response().set_header("Access-Control-Allow-Origin", "*");
        response().set_header("Access-Control-Allow-Headers",
            request().getenv("HTTP_ACCESS_CONTROL_REQUEST_HEADERS"));
        response().set_header("Access-Control-Allow-Methods",
            request().getenv("HTTP_ACCESS_CONTROL_REQUEST_METHOD"));
    }

    void restful::__api__() {
        CORS();
        std::string accept = request().http_accept();

        if(boost::algorithm::contains(accept, "text/yaml")) {
            response().set_header("Content-Type", "text/yaml");
            response().out() << "";
            return;
        }

        response().set_header("Content-Type", "application/json");
        response().out() << "";
    }
}
