/*
{{{appDescription}}}

                        Please DO NOT edit this file
*/

#include "cwapper.hpp"
#include "restful.hpp"

std::ostream& operator<<(std::ostream& out, const boost::property_tree::ptree& v) {
    boost::property_tree::info_parser::write_info(out, v);
    
    return out;
}

namespace cwapper {
    restful::restful(cppcms::service &srv): cppcms::application(srv) {
{{#x-cwapper}}
        dispatcher().assign("{{re}}", &restful::{{fid}}, this{{#hasPathParams}}, {{pathParams.size}}{{/hasPathParams}});
{{/x-cwapper}}

        dispatcher().assign("/__api__", &restful::__api__, this);
    }

// ====================================================================
{{#x-cwapper}}
    void restful::{{fid}}({{#pathParams}}std::string {{paramName}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}) {
{{#pathParams}}
        // {{paramName}}: {{description}}
        {{dataType}} _{{paramName}} = boost::lexical_cast<{{dataType}}>({{paramName}});
{{/pathParams}}

        CORS();

        if (request().request_method() == "OPTIONS") {
            return;
        }

{{#operations}}
        // {{summary}}
{{#description}}
        // {{.}}
{{/description}}
        if (request().request_method() == "{{httpMethod}}") {
{{#allParams}}
{{^isPathParam}}
            // {{paramName}}: {{description}}
            {{dataType}}{{#isListContainer}}<{{baseType}}>{{/isListContainer}} {{paramName}} =
{{#isBodyParam}}
                {{#isListContainer}}restful::array({{/isListContainer}}restful::body(){{#isListContainer}}){{/isListContainer}};
{{/isBodyParam}}
{{^isBodyParam}}
               {{#isListContainer}}boost::get<{{dataType}}<std::string> >(restful::{{#isHeaderParam}}header{{/isHeaderParam}}{{^isHeaderParam}}parameter{{/isHeaderParam}}("{{paramName}}", "{{collectionFormat}}"));{{/isListContainer}}
               {{^isListContainer}}boost::lexical_cast<{{dataType}}>(boost::get<std::string>(restful::{{#isHeaderParam}}header{{/isHeaderParam}}{{^isHeaderParam}}parameter{{/isHeaderParam}}("{{paramName}}")));{{/isListContainer}}
{{/isBodyParam}}
{{/isPathParam}}
{{/allParams}}

            std::cerr << "DEBUG <method>: {{httpMethod}} " << request().path_info() << std::endl;

            {{#returnType}}result({{/returnType}}{{operationId}}({{#allParams}}{{#isPathParam}}_{{/isPathParam}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}){{#returnType}}){{/returnType}};
            return;
        }
{{/operations}}

        response().make_error_response(response().not_implemented);
    }

{{#operations}}
// --------------------------------------------------------------------
    {{#returnType}}{{returnType}}{{^returnSimpleType}}<{{returnBaseType}}>{{/returnSimpleType}}{{/returnType}}{{^returnType}}void{{/returnType}} restful::{{operationId}}({{#allParams}}{{dataType}}{{#isListContainer}}<{{baseType}}>{{/isListContainer}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    {{#bodyParams}}
        return{{#returnType}} {{paramName}}{{/returnType}};
    {{/bodyParams}}
    {{^bodyParams}}
        return{{#returnType}} {{returnType}}{{#returnSimpleType}}(){{/returnSimpleType}}{{^returnSimpleType}}<{{returnBaseType}}>(){{/returnSimpleType}}{{/returnType}};
    {{/bodyParams}}
    }
{{/operations}}
// ====================================================================
{{/x-cwapper}}

    std::vector< boost::property_tree::ptree> restful::array(boost::property_tree::ptree data) {
        return std::vector<boost::property_tree::ptree>(); // FIX me
    }
    
    boost::property_tree::ptree restful::body() {
        std::pair<void*, size_t> post = request().raw_post_data();
        std::istringstream ss(std::string((char *)post.first, post.second));

        std::cerr << "DEBUG <body>:\t" << request().content_type() << std::endl;

        boost::property_tree::ptree tree;

        if (request().content_type() == "application/json") {
            try {
                boost::property_tree::json_parser::read_json(ss, tree);
                boost::property_tree::json_parser::write_json(std::cerr, tree); // DEBUG

            } catch (boost::property_tree::json_parser::json_parser_error &e) {
                response().make_error_response(response().bad_request, e.what());
                throw cwapper::error();
            }
        }
        if (request().content_type() == "text/xml" ||
            request().content_type() == "application/xml" ) {
            try {
                boost::property_tree::xml_parser::read_xml(ss, tree);
                boost::property_tree::xml_parser::write_xml(std::cerr, tree); // DEBUG
            } catch (boost::property_tree::xml_parser::xml_parser_error &e) {
                response().make_error_response(response().bad_request, e.what());
                throw cwapper::error();
            }
        }

        return tree;
    }

    cwapper::parameter restful::header(std::string name) {
        return request().getenv(("HTTP_" + boost::to_upper_copy(name)).c_str()); // cppcms v1.0.5 bug? getenv(string const&) unavailable to linker
    }
    
    cwapper::parameter restful::parameter(std::string name) {
        using namespace boost::algorithm;
    
        cppcms::http::request::form_type form = request().post_or_get();
        cwapper::parameter result;

        return form.find(name)->second;
    }
    
    cwapper::parameter restful::parameter(std::string name, std::string format) {
        using namespace boost::algorithm;
    
        if(format == "csv") {
            std::vector<std::string> csv;
            split(csv, boost::get<std::string>(parameter(name)), is_any_of(","));
            
            return csv;
        }

        // format == multi
        cppcms::http::request::form_type form = request().post_or_get();
        std::vector<std::string> array;

        for(cppcms::http::request::form_type::iterator it = form.begin(); it != form.end(); it++) {
            std::string key = it->first, value = it->second;

            if(name != trim_right_copy_if(key, is_any_of("[]"))) // swagger-ui uses p[]=...&p[]=... while swagger-editor uses p=...&p=...
                continue;
                
            array.push_back(value);
        }
        
        return array;
    }

    template <typename T>
    void restful::result(const T& v) {
        response().content_type("application/json");
        if (request().http_accept() == "application/xml" || request().http_accept() == "text/xml") {
            response().content_type(request().http_accept());
        }
        
        response().out() << v;
    }
    
    void restful::result(const std::vector<boost::property_tree::ptree> &v) {
        boost::property_tree::ptree items;
        boost::property_tree::ptree root;

        for(std::vector<boost::property_tree::ptree>::const_iterator it = v.begin(); it != v.end(); it++) {
            if(request().http_accept() == "application/xml" || request().http_accept() == "text/xml")
                items.push_back(std::make_pair("item", *it));
            else
                items.push_back(std::make_pair("", *it));
        }

        root.add_child("array", items);
        result(root);
    }
    
    void restful::result(const boost::property_tree::ptree& v) {        
        if (request().http_accept() == "application/xml" || request().http_accept() == "text/xml") {
            response().content_type(request().http_accept());
           
            boost::property_tree::xml_parser::write_xml(response().out(), v);
            return;
        }

        response().content_type("application/json");
        boost::property_tree::json_parser::write_json(response().out(), v);
    }

    void restful::CORS() {
        response().set_header("Access-Control-Allow-Origin", "*");
        response().set_header("Access-Control-Allow-Headers",
            request().getenv("HTTP_ACCESS_CONTROL_REQUEST_HEADERS"));
        response().set_header("Access-Control-Allow-Methods",
            request().getenv("HTTP_ACCESS_CONTROL_REQUEST_METHOD"));
    }

    void restful::__api__() {
        CORS();
        std::string accept = request().http_accept();

        if(boost::algorithm::contains(accept, "application/json")) {
            response().content_type("application/json");
            std::ifstream api("api.json", std::ios::binary);
            std::copy(
                std::istreambuf_iterator<char>(api),
                std::istreambuf_iterator<char>(),
                std::ostreambuf_iterator<char>(response().out())
            );

            return;
        }

        response().content_type("application/yaml");
        std::ifstream api("api.yaml", std::ios::binary);
        std::copy(
            std::istreambuf_iterator<char>(api),
            std::istreambuf_iterator<char>(),
            std::ostreambuf_iterator<char>(response().out())
        );
    }
}
